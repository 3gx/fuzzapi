use api;

grammar;

pub L_API : Vec<api::UDTDecl> = {
	<decllist: LUDTDecl+> => {
		// todo fixme: garbage, this should be more than a list of declarations,
		// code should follow
		decllist
	},
};

LUDTDecl: api::UDTDecl = {
	"struct" <nm: LIdentifier> "{" <fields: LField*> "}" => {
		let udt = api::DeclType::Struct(fields);
		api::UDTDecl{name: nm, ty: udt}
	},
	"enum" <nm: LIdentifier> "{" <constant: LConstant+> "}" => {
		api::UDTDecl{name: nm, ty: api::DeclType::Enum(constant)}
	},
};

LIdentifier: String = {
	<nm: r"[[:alpha:]]+[[:alnum:]]*"> => nm.to_string(),
};

LField: api::UDTDecl = {
	"pointer" <blt: LSimpleType> <name: LIdentifier> ";" => {
		let ptr = api::Native::Pointer(Box::new(blt));
		api::UDTDecl{name: name, ty: api::DeclType::Builtin(ptr)}
	},
	<blt: LSimpleType> <name: LIdentifier> ";" => {
		api::UDTDecl{name: name, ty: api::DeclType::Builtin(blt)}
	},
	"struct" <ty: LIdentifier> <name: LIdentifier> ";" => {
		let udt = api::DeclType::StructRef(name);
		api::UDTDecl{name: ty, ty: udt}
	},
	"enum" <ty: LIdentifier> <name: LIdentifier> ";" => {
		api::UDTDecl{name: ty, ty: api::DeclType::EnumRef(name)}
	}
};

LSimpleType: api::Native = {
	"u8" => api::Native::U8, "u16" => api::Native::U16,
	"u32" => api::Native::U32, "u64" => api::Native::U64,
	"usize" => api::Native::Usize,
	"i8" => api::Native::I8, "i16" => api::Native::I16,
	"i32" => api::Native::I32, "i64" => api::Native::I64,
	"int" => api::Native::Integer,
	"void" => api::Native::Void,
	"char" => api::Native::Character,
};

LConstant: api::EnumValue = {
	<nm: LIdentifier> "=" <ival: r"-?[0-9]+"> "," => {
		let v = match ival.parse::<i64>() {
			Err(e) => panic!("error parsing '{}' as an i64."),
			Ok(x) => x,
		};
		(nm, v)
/* this is our ideal definition of LConstant, but: LALRPOP ambiguity.
LConstant: api::EnumValue = {
	<nm: r"[A-Z]+[A-Z0-9]*"> "=" <value: r"-?[0-9]+"> => {
		let v = match value.parse::<i64>() {
			Err(e) => panic!("error parsing '{}' as an i64."),
			Ok(x) => x,
		};
		EnumValue(nm.to_string(), v)
	},
};
*/
	}
};
