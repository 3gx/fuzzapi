// Parsing grammar/code for the user's program abstraction.
use api;
use typ::{Native, Type};
use opcode;
use variable;

grammar;

pub LProgram : api::Program = {
	<decls: LDeclarations> <stmts: LStmt*> => {
		api::Program::new(&decls, &stmts)
	},
};

pub LDeclarations : Vec<api::Declaration> = {
	<decllist: LUDTDecl*> <fvarlist: LFreeVar*> <funclist: LFunc*> => {
		// todo fixme: this should be more than a list of declarations,
		// abstract code should follow
		let mut rv: Vec<api::Declaration> = Vec::new();
		for decl in decllist {
			rv.push(api::Declaration::UDT(decl));
		}
		for fvar in fvarlist {
			rv.push(api::Declaration::Free(fvar));
		}
		for fqn in funclist {
			rv.push(api::Declaration::Function(fqn));
		}
		rv
	},
};

LUDTDecl: api::DeclType = {
	"struct" <nm: LIdentifier> "{" <fields: LField*> "}" => {
		api::DeclType::Struct(nm, fields)
	},
	"enum" <nm: LIdentifier> "{" <constant: LConstant+> "}" => {
		api::DeclType::Enum(nm, constant)
	},
};

LIdentifier: String = {
	<nm: r"[A-Za-z][A-Za-z0-9_]*"> => nm.to_string(),
};
LNum: api::Expr = {
	<num: r"-?[0-9]+"> => api::Expr::IConst(num.to_string()),
	<num: r"-?[0-9]+\.[0-9]+"> => api::Expr::FConst(num.to_string()),
};

LField: api::UDTDecl = {
	"pointer" <blt: LSimpleType> <name: LIdentifier> ";" => {
		let ptr = Type::Pointer(Box::new(Type::Builtin(blt)));
		api::UDTDecl{name: name, ty: api::DeclType::Basic(ptr)}
	},
	<blt: LSimpleType> <name: LIdentifier> ";" => {
		api::UDTDecl{name: name,
		             ty: api::DeclType::Basic(Type::Builtin(blt))}
	},
	"struct" <ty: LIdentifier> <name: LIdentifier> ";" => {
		let udt = api::DeclType::StructRef(name);
		api::UDTDecl{name: ty, ty: udt}
	},
	"enum" <ty: LIdentifier> <name: LIdentifier> ";" => {
		api::UDTDecl{name: ty, ty: api::DeclType::EnumRef(name)}
	}
};

LSimpleType: Native = {
	"u8" => Native::U8, "u16" => Native::U16,
	"u32" => Native::U32, "u64" => Native::U64,
	"usize" => Native::Usize,
	"i8" => Native::I8, "i16" => Native::I16,
	"i32" => Native::I32, "i64" => Native::I64,
	"int" => Native::Integer,
	"void" => Native::Void,
	"char" => Native::Character,
};

LConstant: ::typ::EnumValue = {
	<nm: LIdentifier> "=" <ival: r"-?[0-9]+"> "," => {
		// Ideally we would not allow identifier to have digits, as LIdentifier
		// does, but we cannot due to LALRPOP bug 193.
		let v = match ival.parse::<i64>() {
			Err(e) => panic!("error parsing '{}' as an i64."),
			Ok(x) => x,
		};
		(nm, v)
	}
};

LFreeVar: api::FreeVarDecl = {
	"var:free" <id: LIdentifier> "gen:std:" <gen: LIdentifier>
	<typename: LTypeRef> => {
		api::FreeVarDecl{name: id, genname: "std:".to_string() + &gen, ty: typename}
	},
	"var:free" <id: LIdentifier> "gen:" <gen: LIdentifier>
	<typename: LTypeRef> => {
		api::FreeVarDecl{name: id, genname: gen, ty: typename}
	},
};

LScalarOperation: variable::ScalarOp = {
	"op:null" => variable::ScalarOp::Null,
	"op:*" => variable::ScalarOp::Deref,
	"op:deref" => variable::ScalarOp::Deref,
	"op:&" => variable::ScalarOp::AddressOf,
	"op:addressof" => variable::ScalarOp::AddressOf,
};

LFunc: api::FuncDecl = {
	"function:new" <nm: LIdentifier> <rtype: LTypeRef> "{" <arg: LArgTy*> "}"
		=> {
		api::FuncDecl{name: nm, retval: rtype, arguments: arg}
	},
};

LArgTy: api::DeclType = {
	<tyname: LTypeRef> "," => {
		tyname
	},
};

LBinOp: opcode::Opcode = {
	"+" => opcode::Opcode::Add,
	"-" => opcode::Opcode::Sub,
	"*" => opcode::Opcode::Mul,
	"/" => opcode::Opcode::Div,
	"%" => opcode::Opcode::Mod,
	"&&" => opcode::Opcode::LAnd,
	"||" => opcode::Opcode::LOr,
	">" => opcode::Opcode::Greater,
	"<" => opcode::Opcode::Less,
};

LAddSub: opcode::Opcode = {
	"+" => opcode::Opcode::Add,
	"-" => opcode::Opcode::Sub,
};
LMulDiv: opcode::Opcode = {
	"*" => opcode::Opcode::Mul,
	"/" => opcode::Opcode::Div,
	"%" => opcode::Opcode::Mod,
};
LLogical: opcode::Opcode = {
	"&&" => opcode::Opcode::LAnd,
	"||" => opcode::Opcode::LOr,
};
// We should technically separate out Eq/Ne because they should have lower
// precedence than other relational ops.  But for now ...
LRelational: opcode::Opcode = {
	">" => opcode::Opcode::Greater,
	"<" => opcode::Opcode::Less,
	"==" => opcode::Opcode::Equal,
	"!=" => opcode::Opcode::NotEqual,
};

LTypeRef: api::DeclType = {
	<builtin: LSimpleType> => {
		let ty = Type::Builtin(builtin);
		api::DeclType::Basic(ty)
	},
	"struct" <sref: LIdentifier> => api::DeclType::StructRef(sref),
	"enum" <eref: LIdentifier> => api::DeclType::EnumRef(eref),
	"pointer" <subtype: LTypeRef> => {
		let sty = match subtype {
			api::DeclType::Basic(ty) => ty,
			api::DeclType::StructRef(nm) => Type::Struct(nm, vec![]), // fake struct.
			api::DeclType::EnumRef(nm) => Type::Enum(nm, vec![]), // fake enum.
			_ => panic!("invalid LTypeRef {:?}", subtype),
		};
		let ty = Type::Pointer(Box::new(sty));
		api::DeclType::Basic(ty)
	},
};

LStmt: api::Stmt = {
	<expr: LExpr> => api::Stmt::Basic(expr),
	<lhs: LExpr> "=" <rhs: LExpr> => {
		api::Stmt::Assignment(lhs, rhs)
	},
	"verify:new" <expr: LExpr> => {
		api::Stmt::Verify(expr)
	},
	"constraint:new" <expr: LExpr> => {
		// add parentheses for the expr ?
		api::Stmt::Constraint(expr)
	},
};

LExpr: api::Expr = {
	<term: LTerm> => term,
	<cexpr: LCompoundExpr> => cexpr,
};

LCompoundExpr: api::Expr = {
	<lhs: LTerm> <binop: LBinOp> <rhs: LTerm> => {
		api::Expr::Compound(Box::new(lhs), binop, Box::new(rhs))
	},
};

LTerm: api::Expr = {
	<sop: LScalarOperation> <id: LIdentifier> => {
		api::Expr::VarRef(sop, id)
	},
	<id: LIdentifier> => {
		let sop = variable::ScalarOp::Null;
		api::Expr::VarRef(sop, id)
	},
	"function:call" <id: LIdentifier> "{" <args: LExpr*> "}" => {
		let mut arglist: Vec<Box<api::Expr>> = Vec::new();
		for a in args.iter() {
			arglist.push(Box::new(a.clone()));
		}
		api::Expr::Call(id, arglist)
	},
};
